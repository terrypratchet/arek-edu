1Z0-895
CMT transaction

Server side components:
1.Session beans
a)stateless
b)stateful
c)singleton
2.Message-Driver Beans

Not server side component:
3.Entity Beans

Entity Beans becomes a managed object only when associatd with a construct called EntityManager


In the case of EJB, the Component Model defines our interchangeable parts, and the
Container Services are specialists that perform work upon them. The Specification
provides:

Dependency injection
Concurrency
Instance pooling/caching
Transactions
Security
Timers
Naming and object stores
Interoperability
Lifecycle callbacks
Interceptors
Java Enterprise Platform integration



SESSION BEAN COMPONENT CONTRACT

In the case of a stateful session bean, its lifetime is controlled by the client.

A container may also terminate a session bean instance’s life after a deployer-specified time-
out or as a result of the failure of the server on which the bean instance is running. For this
reason, a client should be prepared to recreate a new session object if it loses the one it is
using.



A container may only passivate a stateful session bean instance when the instance is not in a transaction.
A container must not passivate a stateful session bean with an extended persistence context unless the
following conditions are met: [10]
• All the entities in the persistence context are serializable.
• The EntityManager is serializable.
A stateless session bean is never passivated.
A singleton session bean is never passivated.


The SessionBean interface defines four methods: setSessionContext, ejbRemove, ejb-
Passivate, and ejbActivate.
The ejbPassivate and ejbActivate
methods are only called on stateful session bean instances.

A stateful session bean class can optionally implement the javax.ejb.SessionSynchroniza-
tion interface or annotate methods using the individual @AfterBegin, @BeforeCompletion,
and @AfterCompletion annotations. The deployment descriptor may also be used to declare the
individual session synchronization methods. These provide the session bean instances with transaction
synchronization notifications. The instances can use these notifications, for example, to manage data-
base data they may cache within transactions—e.g., if the Java Persistence API is not used. A stateful
session bean class may use either the javax.ejb.SessionSynchronization interface OR the
session synchronization annotations, but not both






livelocks?


A handle is not a capability, in the security sense, that would automatically grant its holder the right to
invoke methods on the object. When a reference to a session object is obtained from a handle, and then
a method on the session object is invoked, the container performs the usual access checks based on the
caller’s principal.





The wasCancelCalled method enables an asynchronous session bean method to check
whether the client invoked its Future.cancel method. SessionContext.wasCan-
celCalled only returns true if the cancel method was invoked on the client Future
object corresponding to the currently executing business method and the mayInterruptI-
fRunning parameter was set to true.



The PostConstruct lifecycle callback interceptor methods execute in an unspecified security con-
text. The PostConstruct lifecycle callback interceptor methods for stateless and stateful session
beans execute in an unspecified transaction context. The PostConstruct lifecycle callback intercep-
tor methods for singleton beans execute in a transaction context determined by the bean’s transaction
management type and any applicable transaction attribute.


The PrePassivate and PostActivate lifecycle callback interceptor methods are only called on
stateful session bean instances.

The PrePassivate and PostActivate lifecycle callback interceptor methods execute in an
unspecified transaction and security context.



Session Bean Creation
The container creates an instance of a session bean as follows. First, the container calls the bean class’s
newInstance method to create a new session bean instance. Second, the container performs any
dependency injection as specified by metadata annotations on the bean class or by the deployment
descriptor. This includes the bean’s SessionContext, if applicable. Third, the container calls the
PostConstruct lifecycle callback interceptor methods for the bean, if any.


If the stateless session bean instance has an ejbCreate method, the container treats the ejbCreate
method as the instance’s PostConstruct method, and, in this case, the PostConstruct annota-
tion (or deployment descriptor metadata) can only be applied to the bean’s ejbCreate method.

Note that the container never permits multi-threaded
access to the actual stateful session bean instance


The Bean Developer may optionally specify that concurrent client requests to a stateful session bean are
prohibited. This is done using the @AccessTimeout annotation or access-timeout deployment
descriptor element with a value of 0. In this case, if a client-invoked business method is in progress on
an instance when another client-invoked call, from the same or different client, arrives at the same
instance of a stateful session bean, if the second client is a client of the bean’s business interface or
no-interface view, the concurrent invocation must result in the second client receiving a
javax.ejb.ConcurrentAccessException

Transaction Context of Session Bean Methods
The implementation of a method defined in a session bean’s business interface or component interface
or no-interface view, a web service method, timeout callback method, or singleton PostCon-
struct/PreDestroy lifecycle callback interceptor method, is invoked in the scope of a transaction
determined by the transaction attribute specified in the bean’s metadata annotations or deployment
descriptor.
A session bean’s afterBegin and beforeCompletion methods are always called with the same
transaction context as the business methods executed between the afterBegin and beforeCom-
pletion methods.
A session bean’s newInstance, setSessionContext, other dependency injection methods, life
cycle callback interceptor methods, and afterCompletion methods are called with an unspecified
transaction context. Refer to section 13.6.5 for how the container executes methods with an unspecified
transaction context.
For example, it would be wrong to perform database operations within a stateful session bean’s Post-
Construct or PreDestroy lifecycle callback interceptor methods and to assume that the opera-
tions are part of the client’s transaction. The PostConstruct and PreDestroy methods for
stateful and stateless session beans are not controlled by a transaction attribute becaus


Each portable session bean global JNDI name has the following syntax :
java:global[/<app-name>]/<module-name>/<bean-name>[!<fully-quali-
fied-interface-name>]

<bean-name> is the ejb-name of the enterprise bean. For enterprise beans defined via annotation, it
defaults to the unqualified name of the session bean class, unless specified in the contents of the
Stateless/Stateful/Singleton annotation name() attribute. For enterprise beans defined via
ejb-jar.xml, it’s specified in the <ejb-name> deployment descriptor element

If FooBean is packaged in fooejb.jar within fooapp.ear , without the use of any deployment
descriptors, the resulting global JNDI name entries are :
java:global/fooapp/fooejb/FooBean
java:global/fooapp/fooejb/FooBean!com.acme.Foo
java:app/fooejb/FooBean
java:app/fooejb/FooBean!com.acme.Foo
java:module/FooBean
java:module/FooBean!com.acme.Foo


Client transaction context does not propagate with an asynchronous method invocation

A session bean instance’s life starts when a client obtains a reference to a stateful session bean
instance through dependency injection or JNDI lookup, or when the client invokes a cre-
ate<METHOD> method on the session bean’s home interface

The container may not call the beforeCompletion method if the transaction
has been marked for rollback (nor does the instance write any cached updates to the database)


When the client calls a business method of the bean that has been designated as a Remove
method, or a remove method on the home or component interface, the container invokes
PreDestroy lifecycle callback interceptor method(s) (if any) for the bean instance after the
Remove method completes. [

Note that a container can also invoke the PreDestroy
method on the instance without a client call to remove the session object after the lifetime of
the EJB object has expired


-- check!!!
If the Remove method completes successfully or if the Remove
methods throws an application exception for which retainIfException is not true or if a
system exception is thrown, session synchronization methods are not called on the bean
instance. If an application exception is thrown for which retainIfException is true, the
bean is neither destroyed nor discarded, and session synchronization methods, if any, are called
on the instance at the end of transaction.




The PostConstruct, PreDestroy, PrePassivate, PostActivate, Init, and/or
ejbCreate<METHOD>, ejbRemove, ejbPassivate, and ejbActivate methods of
a session bean with container-managed transaction demarcation execute with an unspecified
transaction context.


The getRollbackOnly and setRollbackOnly methods of the SessionContext
interface should be used only in the session bean methods that execute in the context of a trans-
action. The container must throw the java.lang.IllegalStateException if the
methods are invoked while the instance is not associated with a transaction.


The TimerService interface is unavailable to stateful session beans.


A RuntimeException that is not an application exception thrown from any method of the session
bean class (including the business methods and the lifecycle callback interceptor methods invoked by
the container) results in the transition to the “does not exist” state


The following
scenarios result in the PreDestroy lifecycle callback interceptor method(s) not being called for an
instance:
• A crash of the EJB container.
• A system exception thrown from the instance’s method to the container.
• A timeout of client inactivity while the instance is in the passive state.





=============================
@Resource
private SessionContext context; // extends EJBContext
getBusinessObject() = this
getInvokedBusinessInterface() - remote, local or webservice
getCallerPrincipal()


Stateless Session Bean:
-does not exist
-method-read pool

Local interfaces are available only within the same JVM as the session bean. Invoking
on a local interface does not copy the parameters or return value. Because of this, local
interfaces are said to follow what is termed call-by-reference semantics



Nonapplication exceptions are
always wrapped, by the Container, in an EJBException . This means that any exception
you throw that is or extends RuntimeException will be caught by the EJB container and
wrapped in an EJBException




Sessin stateful bean
The container can also move the bean instance from the Method-Ready state to the
Does Not Exist state if the bean times out. Timeouts are declared at deployment time
in a vendor-specific manner. When a timeout occurs in the Method-Ready state, the
container may, but is not required to, call any @PreDestroy callback methods. A stateful
bean cannot time out while a transaction is in progress.

a bean instance
may be passivated (and activated) several times in its life, or not at all.

When a timeout occurs in the Passivated state,
any @PreDestroy callback methods are not invoke

Whenever a system exception is thrown by a bean method, the container invalidates
the EJB object and destroys the bean instance. The bean instance moves directly to the
Does Not Exist state, and any @PreDestroy call methods are not invoked

A system exception is any unchecked exception not annotated as an @Application
Exception , including EJBException


A client application can remove a bean by
invoking a business interface method annotated as @Remove .


=======================\
singleton

In both the stateless and stateful models, the
specification mandates that only one request may access a backing bean instance at any
one time. Because each request is represented by an invocation within a single thread,
this means that SLSB and SFSB implementation classes need not be thread-safe


@javax.ejb.Singleton
@javax.ejb.Startup




===============
MDB
JMS is a vendor-neutral API that can be used to access enterprise messaging systems.

	// use JTA transaction
	@Resource(mappedName = "java:/JmsXA")
	private ConnectionFactory connFactory;

	@Resource(mappedName = "java:/queue/MailToSendQueue")
	private Queue mailQueue;
	
@MessageDriven(
    name = "MailToSendQueue",
    activationConfig = {
        @ActivationConfigProperty( propertyName ="destinationType",
                                   propertyValue="javax.jms.Queue" ),

        @ActivationConfigProperty( propertyName ="destination",
                                   propertyValue="queue/MailToSendQueue" ),

        @ActivationConfigProperty( propertyName ="acknowledgeMode",
                                   propertyValue="Auto-acknowledge" ),
		//see note next to @PoolClass annotation below
        @ActivationConfigProperty( propertyName="maxSession",
                                   propertyValue="5")
    }
    

    
JNDI

SLSBs and SFSBs views must be available in Global
JNDI under this syntax:    
java:global[/app-name]/module-name/bean-name [!FQN]






Timers
The primary difference between a message-driven bean timer and a stateless
session bean timer is the way in which they’re initiated: timers are created in response
to an incoming message or, if the container supports it, from a configuration file.


Transactions
If a system exception or a rollback application exception is thrown by
a business method, the transaction is automatically rolled bac

When an MDB uses container-managed transactions, the
message it handles is a part of the transaction, so if the transaction is rolled back, the
consumption of the message is also rolled back, forcing the JMS provider to redeliver
the message



BMT beans must not use the setRollbackOnly() and getRollbackOnly() methods of the
EJBContext . BMT beans should use the getStatus() and rollback() methods on the
UserTransaction object to check for rollback and force a rollback, respectively.


System
exceptions include java.lang.RuntimeException and its subclasses

Any RuntimeException not annotated with @Applica
tionException that is thrown within a business method (for instance, EJBException ,
NullPointerException , IndexOutOfBoundsException , and so on) is handled by the con-
tainer automatically and results in a transaction rollbac

When a system exception occurs, the EJB instance is discarded, which means that it is
dereferenced and garbage-collected


When stateful session instances are discarded, subsequent invo-
cations of the EJB’s methods by the client result in a NoSuchEJBException , which is a
subclass of RuntimeException


Application exceptions are always delivered directly to the
client without being repackaged as an EJBException type
By default, they do not cause
a transaction to roll back

The @ApplicationException annotation can also be used on subclasses of java.lang.
RuntimeException and java.rmi.RemoteException . This is useful because you may not
want a thrown RuntimeException to be wrapped in an EJBException , or you may not
want a particular subclass of RemoteException to roll back the exception.



