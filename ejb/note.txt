1Z0-895
CMT transaction

Server side components:
1.Session beans
a)stateless
b)stateful
c)singleton
2.Message-Driver Beans

Not server side component:
3.Entity Beans

Entity Beans becomes a managed object only when associatd with a construct called EntityManager


In the case of EJB, the Component Model defines our interchangeable parts, and the
Container Services are specialists that perform work upon them. The Specification
provides:

Dependency injection
Concurrency
Instance pooling/caching
Transactions
Security
Timers
Naming and object stores
Interoperability
Lifecycle callbacks
Interceptors
Java Enterprise Platform integration




livelocks?


=============================
@Resource
private SessionContext context; // extends EJBContext
getBusinessObject() = this
getInvokedBusinessInterface() - remote, local or webservice
getCallerPrincipal()


Stateless Session Bean:
-does not exist
-method-read pool

Local interfaces are available only within the same JVM as the session bean. Invoking
on a local interface does not copy the parameters or return value. Because of this, local
interfaces are said to follow what is termed call-by-reference semantics



Nonapplication exceptions are
always wrapped, by the Container, in an EJBException . This means that any exception
you throw that is or extends RuntimeException will be caught by the EJB container and
wrapped in an EJBException




Sessin stateful bean
The container can also move the bean instance from the Method-Ready state to the
Does Not Exist state if the bean times out. Timeouts are declared at deployment time
in a vendor-specific manner. When a timeout occurs in the Method-Ready state, the
container may, but is not required to, call any @PreDestroy callback methods. A stateful
bean cannot time out while a transaction is in progress.

a bean instance
may be passivated (and activated) several times in its life, or not at all.

When a timeout occurs in the Passivated state,
any @PreDestroy callback methods are not invoke

Whenever a system exception is thrown by a bean method, the container invalidates
the EJB object and destroys the bean instance. The bean instance moves directly to the
Does Not Exist state, and any @PreDestroy call methods are not invoked

A system exception is any unchecked exception not annotated as an @Application
Exception , including EJBException


A client application can remove a bean by
invoking a business interface method annotated as @Remove .


=======================\
singleton

In both the stateless and stateful models, the
specification mandates that only one request may access a backing bean instance at any
one time. Because each request is represented by an invocation within a single thread,
this means that SLSB and SFSB implementation classes need not be thread-safe


@javax.ejb.Singleton
@javax.ejb.Startup




===============
MDB
JMS is a vendor-neutral API that can be used to access enterprise messaging systems.

	// use JTA transaction
	@Resource(mappedName = "java:/JmsXA")
	private ConnectionFactory connFactory;

	@Resource(mappedName = "java:/queue/MailToSendQueue")
	private Queue mailQueue;
	
@MessageDriven(
    name = "MailToSendQueue",
    activationConfig = {
        @ActivationConfigProperty( propertyName ="destinationType",
                                   propertyValue="javax.jms.Queue" ),

        @ActivationConfigProperty( propertyName ="destination",
                                   propertyValue="queue/MailToSendQueue" ),

        @ActivationConfigProperty( propertyName ="acknowledgeMode",
                                   propertyValue="Auto-acknowledge" ),
		//see note next to @PoolClass annotation below
        @ActivationConfigProperty( propertyName="maxSession",
                                   propertyValue="5")
    }
    

    
JNDI

SLSBs and SFSBs views must be available in Global
JNDI under this syntax:    
java:global[/app-name]/module-name/bean-name [!FQN]






Timers
The primary difference between a message-driven bean timer and a stateless
session bean timer is the way in which they’re initiated: timers are created in response
to an incoming message or, if the container supports it, from a configuration file.


Transactions
If a system exception or a rollback application exception is thrown by
a business method, the transaction is automatically rolled bac

When an MDB uses container-managed transactions, the
message it handles is a part of the transaction, so if the transaction is rolled back, the
consumption of the message is also rolled back, forcing the JMS provider to redeliver
the message



BMT beans must not use the setRollbackOnly() and getRollbackOnly() methods of the
EJBContext . BMT beans should use the getStatus() and rollback() methods on the
UserTransaction object to check for rollback and force a rollback, respectively.


System
exceptions include java.lang.RuntimeException and its subclasses

Any RuntimeException not annotated with @Applica
tionException that is thrown within a business method (for instance, EJBException ,
NullPointerException , IndexOutOfBoundsException , and so on) is handled by the con-
tainer automatically and results in a transaction rollbac

When a system exception occurs, the EJB instance is discarded, which means that it is
dereferenced and garbage-collected


When stateful session instances are discarded, subsequent invo-
cations of the EJB’s methods by the client result in a NoSuchEJBException , which is a
subclass of RuntimeException


Application exceptions are always delivered directly to the
client without being repackaged as an EJBException type
By default, they do not cause
a transaction to roll back

The @ApplicationException annotation can also be used on subclasses of java.lang.
RuntimeException and java.rmi.RemoteException . This is useful because you may not
want a thrown RuntimeException to be wrapped in an EJBException , or you may not
want a particular subclass of RemoteException to roll back the exception.



